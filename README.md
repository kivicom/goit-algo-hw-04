# Завдання 1

Python має дві вбудовані функції сортування: sorted і sort. Функції сортування Python використовують Timsort — гібридний алгоритм сортування, що поєднує в собі сортування злиттям і сортування вставками.

Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

## Вибір алгоритмів для порівняння:
Сортування злиттям (Merge Sort) \
Сортування вставками (Insertion Sort) \
Timsort (використовується в Python за допомогою функцій sorted() і методу .sort()) \

## Підготовка наборів даних:
Для тестування алгоритмів використовуйте різні типи наборів даних:

## Випадково згенеровані масиви
Відсортовані масиви\
Масиви, відсортовані в зворотному порядку\
Масиви з повторюваними елементами

<br>----------<br>

## Результати тестування:
* Merge Sort: 0.1887 секунди
* Insertion Sort: 13.000 секунд
* Timsort: 0.0101 секунди

## Аналіз:
* Сортування злиттям (Merge Sort) показало досить хороші результати, що є типовим для алгоритму з часовою складністю O(n log n). Цей алгоритм є досить ефективним на великих масивах і стабільно працює на різних типах даних. 

* Сортування вставками (Insertion Sort) демонструє значно гірший час виконання на великих масивах, оскільки його часова складність в найгіршому випадку є O(n²), що робить його непрактичним для використання у великих або невпорядкованих наборах даних.

* Timsort показав найкращі результати. Це не дивно, адже Timsort оптимізований для різних реальних сценаріїв і може ефективно використовувати внутрішню структуру даних. Timsort має часову складність O(n log n) в загальному випадку і O(n) у найкращому випадку, коли дані вже частково відсортовані.

## Висновки:
* Timsort є надзвичайно ефективним для використання у більшості випадків завдяки його здатності оптимально працювати з різними типами даних і структурою. Він поєднує переваги сортування злиттям та сортування вставками, дозволяючи обробляти великі масиви даних з високою ефективністю.

* Merge Sort також є добрим вибором для великих масивів, особливо коли стабільність сортування є важливою.

* Insertion Sort може бути корисним у ситуаціях, де дані вже майже відсортовані або коли обробляються дуже малі масиви, де вплив квадратичної складності не є критичним.

Ці результати демонструють чому в більшості випадків програмісти вибирають використання вбудованих алгоритмів сортування у Python. Вони оптимізовані, ефективні та забезпечують високу продуктивність без необхідності ручного кодування.

<br>----------<br>

# Завдання 2

Дано k відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. При виконанні завдання можете опиратися на алгоритм сортування злиттям з конспекту. Реалізуйте функцію merge_k_lists , яка приймає на вхід список відсортованих списків та повертає відсортований список.

<br>

Приклад очікуваного результату:

lists = [[1, 4, 5], [1, 3, 4], [2, 6]] \
merged_list = merge_k_lists(lists) \
print("Відсортований список:", merged_list)



Виведення:

Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]